[{"title":"opencv_图像上的算术运算","path":"/2023/10/17/opencv-算术/","content":"图像上的算术运算图像加法我们可以通过OpenCV函数cv2.add()或仅通过numpy操作res = img1 + img2添加两个图像。两个图像应具有相同的深度和类型，或者第二个图像可以只是一个标量值。 1注意: OpenCV加法和Numpy加法之间有区别。OpenCV加法是饱和运算，而Numpy加法是模运算。 123456&gt;&gt;&gt; x = np.uint8([250])&gt;&gt;&gt; y = np.uint8([10])&gt;&gt;&gt; print( cv.add(x,y) ) # 250+10 = 260 =&gt; 255[[255]]&gt;&gt;&gt; print( x+y ) # 250+10 = 260 % 256 = 4[4] 当添加两个图像时，它将更加可见。OpenCV功能将提供更好的结果。因此，始终最好坚持使用OpenCV功能。 图像融合这也是图像加法，但是对图像赋予不同的权重，以使其具有融合或透明的感觉。根据以下等式添加图像：$$G(x) &#x3D; (1-\\alpha)f_0(x)+\\alpha f_1(x)$$通过从$\\alpha$从$0→\\alpha$更改，您可以在一个图像到另一个图像之间执行很酷的过渡。","tags":["opencv"],"categories":["opencv"]},{"title":"opencv 笔记 杂记","path":"/2023/10/17/opencv-learn1/","content":"opencv 笔记导入库1import cv2 读取图片12import cv2img = cv2.imread(&quot;文件路径&quot;) 显示图像12345import cv2img = cv2.imread(&quot;文件路径&quot;)cv2.imshow(&#x27;窗口名称&#x27;，img)cv2.waitKey(0)cv2.destroyAllWindows() a 等，我们将在下面讨论。12```注意 除了键盘绑定事件外，此功能还处理许多其他GUI事件，因此你必须使用它来实际显示图像。 ```cv2.destroyWindow()```在其中传递确切的窗口名称作为参数。1234567891011121314151617## 写入图像使用函数```cv2.imwrite()```保存图像。第一个参数是文件名，第二个参数是要保存的图像。 ```cv2.imwrite(&#x27;messigray.png&#x27;，img)```这会将图像以PNG格式保存在工作目录中。## 访问和修改像素值```pythonimport cv2img = cv2.imread(&quot;文件路径&quot;)px = img[100,100] print(px) 如果图像时灰度图像，则只返回相应的灰度。若为BGR图像则返回一个由蓝色、绿色、红色值组成的数组。 也可以单独访问其蓝色、绿色、红色的值 1234567891011import cv2img = cv2.imread(&quot;文件路径&quot;)blue = img[100,100,0]green = img[100,100,1]red = img[100,100,2]print(&quot;blue&quot;:blue)print(&quot;green&quot;:green)print(&quot;red&quot;:red) 更好的像素访问和编辑方法： 12345678910import cv2img = cv2.imread(&quot;文件路径&quot;)# 访问 RED值print(img.item(100,100,2))# 修改 RED值img.itemset((100,100,2),100)print(img.item(100,100,2)) 访问图像属性图像属性： 行数 列数 通道数 图像数据模型 像素数…. 图像的形状可通过img.shape访问。它返回行、列和通道数的元组(彩色图像) 1**注意** 如果图像是灰度的，则返回的元组仅包含行数和列数，因此这是检查加载的图像是灰度还是彩色的好方法。 像素总数可通过访问img.size图像数据类型通过img.dtype获得","tags":["opencv"],"categories":["opencv"]},{"title":"Python 装饰器","path":"/2023/10/17/Flask-Decirator/","content":"装饰器当我们谈论装饰器时，我们实际上是在谈论一种特殊的语法和设计模式，用于修改或扩展函数的行为，而无需修改函数的定义。 装饰器是一个函数，它接受一个函数作为参数，并返回一个新的函数。这个新的函数通常会在传入的函数之前或之后执行一些额外的操作，或者对传入的函数进行修改。 装饰器的作用是将一些公共的功能逻辑与多个函数进行解耦，从而可以在不修改函数定义的情况下，通过装饰器来添加、修改或扩展函数的行为。 在 Python 中，装饰器使用 @ 符号来应用。当一个函数被装饰器装饰时，它的行为将被装饰器所定义的逻辑所取代。 下面是一个简单的装饰器示例，用于在函数执行前后打印日志信息： 1234567891011121314def log_decorator(func): def wrapper(*args, **kwargs): print(f&quot;Calling function: &#123;func.__name__&#125;&quot;) result = func(*args, **kwargs) print(f&quot;Function &#123;func.__name__&#125; completed&quot;) return result return wrapper@log_decoratordef add_numbers(a, b): return a + bresult = add_numbers(2, 3)print(result) 在上面的例子中，log_decorator 是一个装饰器函数。它接受一个函数作为参数，然后定义了一个内部函数 wrapper，它在调用传入的函数之前和之后打印日志信息。最后，装饰器返回了 wrapper 函数。 通过将 @log_decorator 放在 add_numbers 函数的定义之前，我们将 add_numbers 函数应用了 log_decorator 装饰器。当我们调用 add_numbers 函数时，实际上是调用了装饰器返回的 wrapper 函数，从而实现了在函数执行前后打印日志的功能。 装饰器提供了一种简洁而灵活的方式来修改函数的行为，使代码更加可维护和可重用。在 Flask 中，装饰器广泛应用于定义路由、请求前后的操作、身份验证和权限控制等方面，以实现功能的扩展和定制。","tags":["Python"]},{"title":"Flask杂记","path":"/2023/10/17/FlaskLog/","content":"Flask杂记常用库123456from flask import Flaskfrom flask import redirectfrom flask import render_templatefrom flask import jsonifyfrom flask import requestfrom flask import session 默认情况下，只接受GET请求，要想允许其他请求可以这样：12345from flask import Flask@app.route(&quot;/&quot;,methods=[&#x27;GET&#x27;,&#x27;POST&#x27;])def idnex(): return &quot;HELLO WORLD!&quot;模板渲染数据 app.py 1234567891011121314from flask import Flaskfrom flask import render_template@app.route(&quot;/&quot;,methods=[&#x27;GET&#x27;,&#x27;POST&#x27;])def idnex(): data1 = &#123; &#x27;1&#x27;:&#123;&#x27;name&#x27;:&#x27;mark1&#x27;,&#x27;age&#x27;:&#x27;18&#x27;&#125;, &#x27;2&#x27;:&#123;&#x27;name&#x27;:&#x27;mark2&#x27;,&#x27;age&#x27;:&#x27;19&#x27;&#125;, &#125; data2 = [ &#123;&#x27;id&#x27;:123,&#x27;name&#x27;:&#x27;mark1&#x27;,&#x27;age&#x27;:&#x27;18&#x27;&#125;, &#123;&#x27;id&#x27;:124,&#x27;name&#x27;:&#x27;mark2&#x27;,&#x27;age&#x27;:&#x27;19&#x27;&#125;, ] return render_template(&quot;index.html&quot;,data1=data1,data2=data2) idnex.html 12345678910111213141516171819202122232425262728293031323334353637383940&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Age&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123;% for key, value in data1.items() %&#125; &lt;tr&gt; &lt;th&gt;&#123;&#123;key&#125;&#125;&lt;/th&gt; &lt;th&gt;&#123;&#123;value.name&#125;&#125;&lt;/th&gt; &lt;th&gt;&#123;&#123;value.age&#125;&#125;&lt;/th&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/tbody&gt;&lt;/table&gt;&lt;hr/&gt;&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Age&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123;% for item in data2 %&#125; &lt;tr&gt; &lt;th&gt;&#123;&#123;item.id&#125;&#125;&lt;/th&gt; &lt;th&gt;&#123;&#123;item.name&#125;&#125;&lt;/th&gt; &lt;th&gt;&#123;&#123;item.get&#123;&quot;age&quot;,&quot;22&quot;&#125;&#125;&#125;&lt;/th&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/tbody&gt;&lt;/table&gt; 其中，&#123;&#123;item.get&#123;\"age\",\"22\"&#125;&#125;为获取不到age内容，则返回默认值22 URL 传值12345from flask import Flask@app.route(&quot;/&lt;int:id&quot;,methods=[&#x27;GET&#x27;,&#x27;POST&#x27;])def idnex(): return id url_for 用别名跳转123456789from flask import Flask,url_for@app.route(&quot;/&lt;int:id&quot;,methods=[&#x27;GET&#x27;,&#x27;POST&#x27;],endpoint=&quot;idx&quot;)def idnex(): return id@app.route(&quot;/test/&quot;)def test(): rerurn redirect(url_for(&quot;idx&quot;)) 其中endpoint未填写，默认是函数名，且重名 获取提交的数据123456789from flask import requestfrom flask import Flask@app.route(&quot;/&lt;int:id&quot;,methods=[&#x27;GET&#x27;,&#x27;POST&#x27;])def idnex(): id = request.form.get(&quot;id&quot;) # POST形式传递的参数 name = reuest.args(&quot;name&quot;) # GET形式传递的参数 return id 返回数据12345678910from flask import requestfrom flask import Flaskfrom flask import render_templatefrom flask import jsonify@app.route(&quot;/&lt;int:id&quot;,methods=[&#x27;GET&#x27;,&#x27;POST&#x27;])def idnex(): return render_template(&quot;&quot;) return jsonify() return redirect(&quot;&quot;) return &quot;&quot;","tags":["Flask"]},{"title":"JavaScript进行HTPPS请求","path":"/2023/10/13/js-POST-Get/","content":"在JavaScript中，我们可以使用XMLHttpRequest对象或者fetch API来发送HTTP请求并获取数据。使用XMLHttpRequest对象的示例：12345678910var xhr = new XMLHttpRequest();xhr.open(&#x27;GET&#x27;, &#x27;https://api.example.com/data&#x27;, true);xhr.onreadystatechange = function() &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; var response = JSON.parse(xhr.responseText); // 处理返回的数据 console.log(response); &#125;&#125;;xhr.send(); 使用fetch API的示例：123456789101112131415fetch(&#x27;https://api.example.com/data&#x27;) .then(function(response) &#123; if (response.ok) &#123; return response.json(); &#125; throw new Error(&#x27;Network response was not ok.&#x27;); &#125;) .then(function(data) &#123; // 处理返回的数据 console.log(data); &#125;) .catch(function(error) &#123; // 处理错误 console.log(&#x27;Error:&#x27;, error.message); &#125;); 这些示例中，我们需要将URL替换为你要请求的实际API地址。对于GET请求，我们可以使用xhr.open(&#39;GET&#39;, url, true)或者fetch(url)来发送请求。然后，你可以使用回调函数或者Promise来处理返回的数据。","tags":["JavaScript"]},{"title":"字符串输入输出的相关知识点","path":"/2023/10/08/CppStringCinCout/","content":"字符串输入输出的相关知识点123456789101112131415161718#include &lt;iostream&gt;using namespace std;int main()&#123; char name1[5]; char name2[5]; cout&lt;&lt;&quot;Please Enter Your Name1: &quot;; cin &gt;&gt; name1; cout&lt;&lt;&quot;Please Enter Your Name2: &quot;; cin &gt;&gt; name2; cout &lt;&lt; &quot;Your Name1 is &quot; &lt;&lt; name1 &lt;&lt; &quot; Your Name2 is &quot; &lt;&lt; name2 &lt;&lt; endl; return 0;&#125; 上述代码可以有一下两种输入方式，结果一样的 1234Please Enter Your Name1:Mark YkpPlease Enter Your Name2:Your Name1 is Mark Your Name2 is Ykp 12345Please Enter Your Name1:Mark Please Enter Your Name2:YkpYour Name1 is Mark Your Name2 is Ykp 有这两种输入方式的原因是因为cin不能通过键盘输入空字符\\0来结束字符串，所以cin使用空白（空格、制表符和换行符）来确定字符串的结束位置。这意味cin在获取字符串数组时只能读取一个单词。之后的单词会放在输入队列中，当有新的cin后就出队列到cin中。这也就是为什么会有两种输入方法。","tags":["c++"]},{"title":"部署大模型到微信公众号","path":"/2023/09/09/GPT-ON-WeChat/","content":"部署大模型到微信公众号这是一个Github上的一个项目chatgpt-on-wechat 第一步注册微信公众号关于怎么注册微信公众号这里跳过，自行查找教程。 注册讯飞科大的账号注册账号后并且获得ApiId ApiKey Api Secret这里只需要简单的申请即可获得，具体操作略 运行环境克隆项目代码12git clone https://github.com/zhayujie/chatgpt-on-wechatcd chatgpt-on-wechat/ 安装核心依赖1pip3 install -r requirements.txt 拓展依赖 (可选，建议安装)：1pip3 install -r requirements-optional.txt 其中tiktoken要求python版本在3.8以上，它用于精确计算会话使用的tokens数量，强烈建议安装。 使用google或baidu语音识别需安装ffmpeg， 默认的openai语音识别不需要安装ffmpeg。 配置配置文件的模板在根目录的config-template.json中，需复制该模板创建最终生效的 config.json 文件： 1cp config-template.json config.json 然后在config.json中填入配置 1234567891011121314151617181920212223242526272829&#123; &quot;model&quot;: &quot;xunfei&quot;, &quot;xunfei_app_id&quot;: &quot;appid&quot;, &quot;xunfei_api_key&quot;: &quot;apikey&quot;, &quot;xunfei_api_secret&quot;: &quot;apisecret&quot;, &quot;channel_type&quot;: &quot;wx&quot;, &quot;proxy&quot;: &quot;&quot;, &quot;hot_reload&quot;: false, &quot;single_chat_prefix&quot;: [ &quot;猫猫&quot;, &quot;猫&quot;, &quot;&quot; ], &quot;image_create_prefix&quot;: [ &quot;画&quot;, &quot;看&quot;, &quot;找&quot; ], &quot;speech_recognition&quot;: false, &quot;group_speech_recognition&quot;: false, &quot;voice_reply_voice&quot;: false, &quot;conversation_max_tokens&quot;: 1000, &quot;expires_in_seconds&quot;: 3600, &quot;character_desc&quot;: &quot;你是猫猫, 一个大型语言模型, 你旨在回答并解决人们的任何问题，并且可以使用多种语言与人交流。请遵循法律法规&quot;, &quot;temperature&quot;: 0.7, &quot;top_p&quot;: 1, &quot;subscribe_msg&quot;: &quot;喵~感谢您的关注！ 这里是猫猫，可以自由对话。 支持语音输入。 支持图片输入(后续OTA支持)。 支持图片输出(后续OTA支持)，画字开头的消息将按要求创作图片(后续OTA支持)。 支持tool、角色扮演和文字冒险等丰富的插件（后续OTA支持）。 输入 猫猫 #help 查看详细指令。&quot;, &quot;use_linkai&quot;: false,&#125; 微信公众号配置先在服务器下载下面这个脚本模块 12pip3 install web.pypip3 install wechatpy 将公众号接入小程序然后根据接入指南的说明，在微信公众平台的“设置与开发”-“基本配置”-“服务器配置”中填写服务器地址URL和令牌Token。URL填写格式为http://url/wx，可使用IP（成功几率看脸），Token是你自己编的一个特定的令牌。消息加解密方式如果选择了需要加密的模式，需要在配置中填写wechatmp_aes_key。 相关的服务器验证代码已经写好，你不需要再添加任何代码。你只需要在本项目根目录的config.json中添加 123456789&quot;channel_type&quot;: &quot;wechatmp&quot;, &quot;wechatmp_token&quot;: &quot;xxxx&quot;, &quot;wechatmp_port&quot;: 8080, &quot;wechatmp_app_id&quot;: &quot;xxxx&quot;, &quot;wechatmp_app_secret&quot;: &quot;xxxx&quot;, &quot;wechatmp_aes_key&quot;: &quot;&quot;, &quot;single_chat_prefix&quot;: [&quot;&quot;], &quot;single_chat_reply_prefix&quot;: &quot;&quot;, &quot;plugin_trigger_prefix&quot;: &quot;&amp;&quot;, 然后运行python3 app.py启动web服务器。这里会默认监听8080端口，但是微信公众号的服务器配置只支持80&#x2F;443端口，有两种方法来解决这个问题。第一个是推荐的方法，使用端口转发命令将80端口转发到8080端口： 12sudo iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080sudo iptables-save &gt; /etc/iptables/rules.v4 如果第二行命令无效，则只执行第一行命令即可，但是若服务器重启，需要重新输入第一行的命令 运行本地运行如果是开发机 本地运行，直接在项目根目录下执行： 1python3 app.py 即可 服务器部署使用nohup命令在后台运行程序： 12touch nohup.out # 首次运行需要新建日志文件 nohup python3 app.py &amp; tail -f nohup.out # 在后台运行程序并通过日志输出二维码 扫码登录后程序即可运行于服务器后台，此时可通过 ctrl+c 关闭日志，不会影响后台程序的运行。使用 ps -ef | grep app.py | grep -v grep命令可查看运行于后台的进程，如果想要重新启动程序可以先 kill 掉对应的进程。日志关闭后如果想要再次打开只需输入 tail -f nohup.out。此外，scripts 目录下有一键运行、关闭程序的脚本供使用。"},{"title":"Unity碰撞检测","path":"/2023/08/31/Unity碰撞检测/","content":"碰撞检测OnTriggerOnTrigger有三个方法： 1234void OnTriggerEnter(Collider2D collision);void OnTriggerStay(Collider2D collision);void OnTriggerExit(Collider2D collision); 且至少有一方添加刚体组件，并勾选碰撞体组件中的```Is Trigger```属性12345678910---## OnCollisionOnCollision有三个方法：```C#void OnCollisionEnter(Collision collision);void OnCollisionStay(Collision collision);void OnCollisionExit(Collision collision); OnCollision：不仅进行碰撞检测，并且有物理效果，如两物体会进行相撞。 至少有一方添加刚体组件，并都不勾选碰撞体组件中的Is Trigger属性","categories":["Unity游戏开发"]},{"title":"导航栏简单制作","path":"/2023/08/31/导航栏简单制作/","content":"导航栏制作 这里用微信小程序为例，写一个导航栏例子。大体思路就是先在wxml页面渲染是每个标签带有一个for循环的index数据，然后再应试选择当前选择项是否等于标签本身带有的index数据即可。js脚本用于处理点击事件。 WXML页面代码 12345&lt;scroll-view class=&quot;listMenu&quot; scroll-y scroll-with-animation scroll-top=&quot;&#123;&#123;scrollTops&#125;&#125;&quot;&gt; &lt;view class=&quot;menuBox &quot; wx:for=&quot;&#123;&#123;foodDatas&#125;&#125;&quot;&gt; &lt;view class=&quot;menuName &#123;&#123;tabCur===index?&#x27;menuActive&#x27;:&#x27;&#x27;&#125;&#125;&quot; bindtap=&quot;bindTapMenuList&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot;&gt;&#123;&#123;item.typeName&#125;&#125;&lt;/view&gt; &lt;/view&gt;&lt;/scroll-view&gt; 这是写的是侧边栏的样式 12345678910111213141516171819.listMenu&#123; width: 120rpx; /* margin-left: 20rpx; */ display: flex; flex-direction: column;&#125;.menuBox&#123; display: flex; flex-direction: column; margin-bottom: 20rpx; text-align: center;&#125;.menuName&#123; margin-top: 5rpx;&#125;.menuActive&#123; background-color: red; /* border-radius: 20rpx; */&#125; JavaScript脚本 12345678910111213141516171819202122232425Page(&#123; /** * 页面的初始数据 */ data: &#123; menuList:[ &#123;menuImg:&quot;&quot;,menuName:&quot;套餐&quot;,isActive:true&#125;, &#123;menuImg:&quot;&quot;,menuName:&quot;汉堡&quot;,isActive:false&#125;, &#123;menuImg:&quot;&quot;,menuName:&quot;炸鸡&quot;,isActive:false&#125;, &#123;menuImg:&quot;&quot;,menuName:&quot;小食&quot;,isActive:false&#125;, &#123;menuImg:&quot;&quot;,menuName:&quot;饮料&quot;,isActive:false&#125;, &#123;menuImg:&quot;&quot;,menuName:&quot;小料&quot;,isActive:false&#125;, ], tabCur: 0, // 当前项 &#125;, bindTapMenuList(e)&#123; let index = e.currentTarget.dataset.index; this.setData(&#123; tabCur: index, &#125;) &#125;,&#125;)"},{"title":"JavaScript数组笔记","path":"/2023/08/31/JavaScript数组笔记/","content":"JavaScript的数组笔记创建数组 常规方式:1234var myCars=new Array();myCars[0]=&quot;Saab&quot;; myCars[1]=&quot;Volvo&quot;;myCars[2]=&quot;BMW&quot;; 简洁方式:1var myCars=new Array(&quot;Saab&quot;,&quot;Volvo&quot;,&quot;BMW&quot;); 字面:1var myCars=[&quot;Saab&quot;,&quot;Volvo&quot;,&quot;BMW&quot;]; 数组属性 属性 描述 constrcutor 返回创建数组对象的原型函数。 length 设置或返回数组元素的个数。 prototype 允许你向数组对象添加属性或方法。 数组对象方法 方法 描述 concat() 连接两个或更多的数组，并返回结果。 copyWithin() 从数组的指定位置拷贝元素到数组的另一个指定位置中。 entries() 返回数组的可迭代对象。 every() 检测数值元素的每个元素是否都符合条件。 fill() 使用一个固定值来填充数组。 filter() 检测数值元素，并返回符合条件所有元素的数组。 find() 返回符合传入测试（函数）条件的数组元素。 findIndex() 返回符合传入测试（函数）条件的数组元素索引。 forEach() 数组每个元素都执行一次回调函数。 from() 通过给定的对象中创建一个数组。 includes() 判断一个数组是否包含一个指定的值。 indexOf() 搜索数组中的元素，并返回它所在的位置。 isArray() 判断对象是否为数组。 join() 把数组的所有元素放入一个字符串。 keys() 返回数组的可迭代对象，包含原始数组的键(key)。 lastIndexOf() 搜索数组中的元素，并返回它最后出现的位置。 map() 通过指定函数处理数组的每个元素，并返回处理后的数组。 pop() 删除数组的最后一个元素并返回删除的元素。 push() 向数组的末尾添加一个或更多元素，并返回新的长度。 reduce() 将数组元素计算为一个值（从左到右）。 reduceRight() 将数组元素计算为一个值（从右到左）。 reverse() 反转数组的元素顺序。 shift() 删除并返回数组的第一个元素。 slice() 选取数组的一部分，并返回一个新数组。 some() 检测数组元素中是否有元素符合指定条件。 sort() 对数组的元素进行排序。 splice() 从数组中添加或删除元素。 toString() 把数组转换为字符串，并返回结果。 unshift() 向数组的开头添加一个或更多元素，并返回新的长度。 valueOf() 返回数组对象的原始值。 Array.of() 将一组值转换为数组。 Array.at() 用于接收一个整数值并返回该索引对应的元素，允许正数和负数。负整数从数组中的最后一个元素开始倒数。 Array.flat() 创建一个新数组，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。 Array.flatMap() 使用映射函数映射每个元素，然后将结果压缩成一个新数组。 concat() 合并数组 1234var a = [&quot;Google&quot;, &quot;Taobao&quot;];var b = [&quot;Runoob&quot;, &quot;Wiki&quot;, &quot;Zhihu&quot;];var c = a.concat(b);document.write(c); 输出结果 1Google,Taobao,Runoob,Wiki,Zhihu copyWithin() 方法用于从数组的指定位置拷贝元素到数组的另一个指定位置中。复制数组的前面两个元素到后面两个元素上： 12var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.copyWithin(2, 0); fruits 输出结果： 1Banana,Orange,Banana,Orange findIndex() 方法返回传入一个测试条件（函数）符合条件的数组第一个元素位置。 findIndex() 方法为数组中的每个元素都调用一次函数执行： 当数组中的元素在测试条件时返回 true 时, findIndex() 返回符合条件的元素的索引位置，之后的值不会再调用执行函数。 如果没有符合条件的元素返回 -1 注意: findIndex() 对于空数组，函数是不会执行的。 注意: findIndex() 并没有改变数组的原始值。 12var isInList = settlementList.findIndex(v=&gt;v.name === foodInfoNew.name)","categories":["前端","Javascript"]},{"title":"微信小程序数据缓存使用","path":"/2023/08/31/微信小程序数据缓存使用/","content":"微信小程序数据缓存使用数据储存将数据存储在本地缓存中指定的 key 中。会覆盖掉原来该 key 对应的内容。除非用户主动删除或因存储空间原因被系统清理，否则数据都一直可用。单个 key 允许存储的最大数据长度为 1MB，所有数据存储上限为 10MB。 1234567891011//同步操作wx.setStorageSync(&#x27;key&#x27;, &#x27;value&#x27;)//异步操作wx.setStorage(&#123; key: &quot;key&quot;, data: &quot;value&quot;, encrypt: true, // 若开启加密存储，setStorage 和 getStorage 需要同时声明 encrypt 的值为 true success(res) &#123; &#125;&#125;) 数据获取从本地缓存中同步获取指定 key 的内容。 12345678910//同步操作var value = wx.getStorageSync(&#x27;key&#x27;)//异步操作wx.getStorage(&#123; key: &quot;key&quot;, encrypt: true, // 若开启加密存储，setStorage 和 getStorage 需要同时声明 encrypt 的值为 true success(res) &#123; console.log(res.data) &#125; &#125;)"},{"title":"Hello World","path":"/2023/08/30/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]