[{"title":"部署大模型到微信公众号","path":"/2023/09/09/GPT-ON-WeChat/","content":"部署大模型到微信公众号这是一个Github上的一个项目chatgpt-on-wechat 第一步注册微信公众号关于怎么注册微信公众号这里跳过，自行查找教程。 注册讯飞科大的账号注册账号后并且获得ApiId ApiKey Api Secret这里只需要简单的申请即可获得，具体操作略 运行环境克隆项目代码12git clone https://github.com/zhayujie/chatgpt-on-wechatcd chatgpt-on-wechat/ 安装核心依赖1pip3 install -r requirements.txt 拓展依赖 (可选，建议安装)：1pip3 install -r requirements-optional.txt 其中tiktoken要求python版本在3.8以上，它用于精确计算会话使用的tokens数量，强烈建议安装。 使用google或baidu语音识别需安装ffmpeg， 默认的openai语音识别不需要安装ffmpeg。 配置配置文件的模板在根目录的config-template.json中，需复制该模板创建最终生效的 config.json 文件： 1cp config-template.json config.json 然后在config.json中填入配置 1234567891011121314151617181920212223242526272829&#123; &quot;model&quot;: &quot;xunfei&quot;, &quot;xunfei_app_id&quot;: &quot;appid&quot;, &quot;xunfei_api_key&quot;: &quot;apikey&quot;, &quot;xunfei_api_secret&quot;: &quot;apisecret&quot;, &quot;channel_type&quot;: &quot;wx&quot;, &quot;proxy&quot;: &quot;&quot;, &quot;hot_reload&quot;: false, &quot;single_chat_prefix&quot;: [ &quot;猫猫&quot;, &quot;猫&quot;, &quot;&quot; ], &quot;image_create_prefix&quot;: [ &quot;画&quot;, &quot;看&quot;, &quot;找&quot; ], &quot;speech_recognition&quot;: false, &quot;group_speech_recognition&quot;: false, &quot;voice_reply_voice&quot;: false, &quot;conversation_max_tokens&quot;: 1000, &quot;expires_in_seconds&quot;: 3600, &quot;character_desc&quot;: &quot;你是猫猫, 一个大型语言模型, 你旨在回答并解决人们的任何问题，并且可以使用多种语言与人交流。请遵循法律法规&quot;, &quot;temperature&quot;: 0.7, &quot;top_p&quot;: 1, &quot;subscribe_msg&quot;: &quot;喵~感谢您的关注！ 这里是猫猫，可以自由对话。 支持语音输入。 支持图片输入(后续OTA支持)。 支持图片输出(后续OTA支持)，画字开头的消息将按要求创作图片(后续OTA支持)。 支持tool、角色扮演和文字冒险等丰富的插件（后续OTA支持）。 输入 猫猫 #help 查看详细指令。&quot;, &quot;use_linkai&quot;: false,&#125; 微信公众号配置先在服务器下载下面这个脚本模块 12pip3 install web.pypip3 install wechatpy 将公众号接入小程序然后根据接入指南的说明，在微信公众平台的“设置与开发”-“基本配置”-“服务器配置”中填写服务器地址URL和令牌Token。URL填写格式为http://url/wx，可使用IP（成功几率看脸），Token是你自己编的一个特定的令牌。消息加解密方式如果选择了需要加密的模式，需要在配置中填写wechatmp_aes_key。 相关的服务器验证代码已经写好，你不需要再添加任何代码。你只需要在本项目根目录的config.json中添加 123456789&quot;channel_type&quot;: &quot;wechatmp&quot;, &quot;wechatmp_token&quot;: &quot;xxxx&quot;, &quot;wechatmp_port&quot;: 8080, &quot;wechatmp_app_id&quot;: &quot;xxxx&quot;, &quot;wechatmp_app_secret&quot;: &quot;xxxx&quot;, &quot;wechatmp_aes_key&quot;: &quot;&quot;, &quot;single_chat_prefix&quot;: [&quot;&quot;], &quot;single_chat_reply_prefix&quot;: &quot;&quot;, &quot;plugin_trigger_prefix&quot;: &quot;&amp;&quot;, 然后运行python3 app.py启动web服务器。这里会默认监听8080端口，但是微信公众号的服务器配置只支持80&#x2F;443端口，有两种方法来解决这个问题。第一个是推荐的方法，使用端口转发命令将80端口转发到8080端口： 12sudo iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080sudo iptables-save &gt; /etc/iptables/rules.v4 如果第二行命令无效，则只执行第一行命令即可，但是若服务器重启，需要重新输入第一行的命令 运行本地运行如果是开发机 本地运行，直接在项目根目录下执行： 1python3 app.py 即可 服务器部署使用nohup命令在后台运行程序： 12touch nohup.out # 首次运行需要新建日志文件 nohup python3 app.py &amp; tail -f nohup.out # 在后台运行程序并通过日志输出二维码 扫码登录后程序即可运行于服务器后台，此时可通过 ctrl+c 关闭日志，不会影响后台程序的运行。使用 ps -ef | grep app.py | grep -v grep命令可查看运行于后台的进程，如果想要重新启动程序可以先 kill 掉对应的进程。日志关闭后如果想要再次打开只需输入 tail -f nohup.out。此外，scripts 目录下有一键运行、关闭程序的脚本供使用。"},{"title":"Unity碰撞检测","path":"/2023/08/31/Unity碰撞检测/","content":"碰撞检测OnTriggerOnTrigger有三个方法： 1234void OnTriggerEnter(Collider2D collision);void OnTriggerStay(Collider2D collision);void OnTriggerExit(Collider2D collision); 且至少有一方添加刚体组件，并勾选碰撞体组件中的```Is Trigger```属性12345678910---## OnCollisionOnCollision有三个方法：```C#void OnCollisionEnter(Collision collision);void OnCollisionStay(Collision collision);void OnCollisionExit(Collision collision); OnCollision：不仅进行碰撞检测，并且有物理效果，如两物体会进行相撞。 至少有一方添加刚体组件，并都不勾选碰撞体组件中的Is Trigger属性","categories":["Unity游戏开发"]},{"title":"导航栏简单制作","path":"/2023/08/31/导航栏简单制作/","content":"导航栏制作 这里用微信小程序为例，写一个导航栏例子。大体思路就是先在wxml页面渲染是每个标签带有一个for循环的index数据，然后再应试选择当前选择项是否等于标签本身带有的index数据即可。js脚本用于处理点击事件。 WXML页面代码 12345&lt;scroll-view class=&quot;listMenu&quot; scroll-y scroll-with-animation scroll-top=&quot;&#123;&#123;scrollTops&#125;&#125;&quot;&gt; &lt;view class=&quot;menuBox &quot; wx:for=&quot;&#123;&#123;foodDatas&#125;&#125;&quot;&gt; &lt;view class=&quot;menuName &#123;&#123;tabCur===index?&#x27;menuActive&#x27;:&#x27;&#x27;&#125;&#125;&quot; bindtap=&quot;bindTapMenuList&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot;&gt;&#123;&#123;item.typeName&#125;&#125;&lt;/view&gt; &lt;/view&gt;&lt;/scroll-view&gt; 这是写的是侧边栏的样式 12345678910111213141516171819.listMenu&#123; width: 120rpx; /* margin-left: 20rpx; */ display: flex; flex-direction: column;&#125;.menuBox&#123; display: flex; flex-direction: column; margin-bottom: 20rpx; text-align: center;&#125;.menuName&#123; margin-top: 5rpx;&#125;.menuActive&#123; background-color: red; /* border-radius: 20rpx; */&#125; JavaScript脚本 12345678910111213141516171819202122232425Page(&#123; /** * 页面的初始数据 */ data: &#123; menuList:[ &#123;menuImg:&quot;&quot;,menuName:&quot;套餐&quot;,isActive:true&#125;, &#123;menuImg:&quot;&quot;,menuName:&quot;汉堡&quot;,isActive:false&#125;, &#123;menuImg:&quot;&quot;,menuName:&quot;炸鸡&quot;,isActive:false&#125;, &#123;menuImg:&quot;&quot;,menuName:&quot;小食&quot;,isActive:false&#125;, &#123;menuImg:&quot;&quot;,menuName:&quot;饮料&quot;,isActive:false&#125;, &#123;menuImg:&quot;&quot;,menuName:&quot;小料&quot;,isActive:false&#125;, ], tabCur: 0, // 当前项 &#125;, bindTapMenuList(e)&#123; let index = e.currentTarget.dataset.index; this.setData(&#123; tabCur: index, &#125;) &#125;,&#125;)"},{"title":"JavaScript数组笔记","path":"/2023/08/31/JavaScript数组笔记/","content":"JavaScript的数组笔记创建数组 常规方式:1234var myCars=new Array();myCars[0]=&quot;Saab&quot;; myCars[1]=&quot;Volvo&quot;;myCars[2]=&quot;BMW&quot;; 简洁方式:1var myCars=new Array(&quot;Saab&quot;,&quot;Volvo&quot;,&quot;BMW&quot;); 字面:1var myCars=[&quot;Saab&quot;,&quot;Volvo&quot;,&quot;BMW&quot;]; 数组属性 属性 描述 constrcutor 返回创建数组对象的原型函数。 length 设置或返回数组元素的个数。 prototype 允许你向数组对象添加属性或方法。 数组对象方法 方法 描述 concat() 连接两个或更多的数组，并返回结果。 copyWithin() 从数组的指定位置拷贝元素到数组的另一个指定位置中。 entries() 返回数组的可迭代对象。 every() 检测数值元素的每个元素是否都符合条件。 fill() 使用一个固定值来填充数组。 filter() 检测数值元素，并返回符合条件所有元素的数组。 find() 返回符合传入测试（函数）条件的数组元素。 findIndex() 返回符合传入测试（函数）条件的数组元素索引。 forEach() 数组每个元素都执行一次回调函数。 from() 通过给定的对象中创建一个数组。 includes() 判断一个数组是否包含一个指定的值。 indexOf() 搜索数组中的元素，并返回它所在的位置。 isArray() 判断对象是否为数组。 join() 把数组的所有元素放入一个字符串。 keys() 返回数组的可迭代对象，包含原始数组的键(key)。 lastIndexOf() 搜索数组中的元素，并返回它最后出现的位置。 map() 通过指定函数处理数组的每个元素，并返回处理后的数组。 pop() 删除数组的最后一个元素并返回删除的元素。 push() 向数组的末尾添加一个或更多元素，并返回新的长度。 reduce() 将数组元素计算为一个值（从左到右）。 reduceRight() 将数组元素计算为一个值（从右到左）。 reverse() 反转数组的元素顺序。 shift() 删除并返回数组的第一个元素。 slice() 选取数组的一部分，并返回一个新数组。 some() 检测数组元素中是否有元素符合指定条件。 sort() 对数组的元素进行排序。 splice() 从数组中添加或删除元素。 toString() 把数组转换为字符串，并返回结果。 unshift() 向数组的开头添加一个或更多元素，并返回新的长度。 valueOf() 返回数组对象的原始值。 Array.of() 将一组值转换为数组。 Array.at() 用于接收一个整数值并返回该索引对应的元素，允许正数和负数。负整数从数组中的最后一个元素开始倒数。 Array.flat() 创建一个新数组，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。 Array.flatMap() 使用映射函数映射每个元素，然后将结果压缩成一个新数组。 concat() 合并数组 1234var a = [&quot;Google&quot;, &quot;Taobao&quot;];var b = [&quot;Runoob&quot;, &quot;Wiki&quot;, &quot;Zhihu&quot;];var c = a.concat(b);document.write(c); 输出结果 1Google,Taobao,Runoob,Wiki,Zhihu copyWithin() 方法用于从数组的指定位置拷贝元素到数组的另一个指定位置中。复制数组的前面两个元素到后面两个元素上： 12var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.copyWithin(2, 0); fruits 输出结果： 1Banana,Orange,Banana,Orange findIndex() 方法返回传入一个测试条件（函数）符合条件的数组第一个元素位置。 findIndex() 方法为数组中的每个元素都调用一次函数执行： 当数组中的元素在测试条件时返回 true 时, findIndex() 返回符合条件的元素的索引位置，之后的值不会再调用执行函数。 如果没有符合条件的元素返回 -1 注意: findIndex() 对于空数组，函数是不会执行的。 注意: findIndex() 并没有改变数组的原始值。 12var isInList = settlementList.findIndex(v=&gt;v.name === foodInfoNew.name)","categories":["前端","Javascript"]},{"title":"微信小程序数据缓存使用","path":"/2023/08/31/微信小程序数据缓存使用/","content":"微信小程序数据缓存使用数据储存将数据存储在本地缓存中指定的 key 中。会覆盖掉原来该 key 对应的内容。除非用户主动删除或因存储空间原因被系统清理，否则数据都一直可用。单个 key 允许存储的最大数据长度为 1MB，所有数据存储上限为 10MB。 1234567891011//同步操作wx.setStorageSync(&#x27;key&#x27;, &#x27;value&#x27;)//异步操作wx.setStorage(&#123; key: &quot;key&quot;, data: &quot;value&quot;, encrypt: true, // 若开启加密存储，setStorage 和 getStorage 需要同时声明 encrypt 的值为 true success(res) &#123; &#125;&#125;) 数据获取从本地缓存中同步获取指定 key 的内容。 12345678910//同步操作var value = wx.getStorageSync(&#x27;key&#x27;)//异步操作wx.getStorage(&#123; key: &quot;key&quot;, encrypt: true, // 若开启加密存储，setStorage 和 getStorage 需要同时声明 encrypt 的值为 true success(res) &#123; console.log(res.data) &#125; &#125;)"},{"title":"Hello World","path":"/2023/08/30/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]